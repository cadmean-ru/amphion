package utils

import (
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"
)

const resIndexTemplate = `const {{ .Name }} = {{ .Index }} //{{ .Path }}`
const resIndexFileTemplate = `
package main

// This file is automatically generated.
// DO NOT EDIT THIS FILE MANUALLY!!!

{{ .Resources }}
`

func GenerateResourcesIndices(resDirPath, outFilePath string) {
	paths := scanDirectory(resDirPath)

	tmpl := template.Must(template.New("resIndex").Parse(resIndexTemplate))

	sb := &strings.Builder{}

	for i, p := range paths {
		_ = tmpl.Execute(sb, struct{
			Name string
			Index int
			Path string
		} {
			Name: resName(p),
			Index: i,
			Path: p,
		})

		sb.WriteRune('\n')
	}

	outFile, err := os.Create(outFilePath)
	if err != nil {
		log.Fatal(err)
	}

	tmpl2 := template.Must(template.New("resFile").Parse(resIndexFileTemplate))

	_ = tmpl2.Execute(outFile, struct{
		Resources string
	} {
		Resources: sb.String(),
	})
}

var validVarName = regexp.MustCompile("^[_A-z]+[_A-z$0-9]*$")

func scanDirectory(path string) []string {
	files, err := ioutil.ReadDir(path)
	if err != nil {
		return []string {}
	}

	paths := make([]string, 0)

	for _, f := range files {
		if f.Name()[0] == '.' {
			continue
		}

		fullPath := path + "/" + f.Name()

		if f.IsDir() {
			paths = append(paths, scanDirectory(fullPath)...)
		} else {
			if !validVarName.MatchString(resName(fullPath)) {
				continue
			}
			paths = append(paths, fullPath)
		}
	}

	return paths
}

var notW = regexp.MustCompile("\\W")

func resName(path string) string {
	var s = path
	s = s[strings.Index(s, "res")+4:strings.LastIndex(s, ".")]
	s = strings.ReplaceAll(s, "/", "_")
	s = strings.ReplaceAll(s, " ", "")
	s = notW.ReplaceAllString(s, "")
	return "Res_" + s
}